model CastingFunctions;

type string String min-size:0 max-size:255;
type boolean Boolean;

entity A {
    field String nameA;
}

entity B extends A {
    field String nameB;
}

entity CA extends B {
    field String nameCA;
}


entity CB extends B {
    field String nameCB;
}

entity Tester {
    relation B b;
    relation B[] bs;
    relation B caAsB;
    relation B[] caAsBs;

    // kind of
    field Boolean kindOfA <= self.b.kindOf(type = A);        // true
    field Boolean kindOfB <= self.b.kindOf(type = B);        // true
    field Boolean kindOfCA <= self.b.kindOf(type = CA);      // false
    field Boolean kindOfCA1 <= self.caAsB.kindOf(type = CA); // true
    field Boolean kindOfCB <= self.b.kindOf(type = CB);      // false

    // type of
    field Boolean typeOfA <= self.b.typeOf(type = A);        // false
    field Boolean typeOfB <= self.b.typeOf(type = B);        // true
    field Boolean typeOfCA <= self.b.typeOf(type = CA);      // false
    field Boolean typeOfCA1 <= self.caAsB.typeOf(type = CA); // true
    field Boolean typeOfCB <= self.b.typeOf(type = CB);      // false

    // as type
    relation A asTypeA <= self.b.asType(type = A);         // B
    relation B asTypeB <= self.b.asType(type = B);         // B
    relation CA asTypeCA <= self.b.asType(type = CA);      // undefined
    relation CA asTypeCA1 <= self.caAsB.asType(type = CA); // CA
    relation CB asTypeCB <= self.b.asType(type = CB);      // undefined

    // as collection
    relation A[] asCollectionA <= self.bs.asCollection(type = A);         // B-s
    relation B[] asCollectionB <= self.bs.asCollection(type = B);         // B-s
    relation CA[] asCollectionCA <= self.bs.asCollection(type = CA);      // empty
    relation CA[] asCollectionCA1 <= self.caAsBs.asCollection(type = CA); // CA-s
    relation CB[] asCollectionCB <= self.bs.asCollection(type = CB);      // empty

    // SubTypeExpression
    relation A[] caAs <= A.all().filter( a | a.nameA.like(pattern = "aca_"));
    relation B[] caBs <= B.all().filter( a | a.nameA.like(pattern = "aca_"));
    relation CA[] caCAs <= CA.all().filter( a | a.nameA.like(pattern = "aca_"));
    relation CB[] caCBs <= CB.all().filter( a | a.nameA.like(pattern = "aca_"));
    relation B[] caAsCollectionB <= A.all().asCollection(type = B).filter( a | a.nameA.like(pattern = "aca_"));

}

// TRANSFER REPRESENTATION

transfer TA maps A as a {
    field String nameA <=> a.nameA;
}

transfer TB maps B as b {
    field String nameA <=> b.nameA;
    field String nameB <=> b.nameB;
}

transfer TCA maps CA as ca {
    field String nameA <=> ca.nameA;
    field String nameCA <=> ca.nameCA;
    field String nameB <=> ca.nameB;
}


transfer TCB maps CB as cb {
    field String nameA <=> cb.nameA;
    field String nameCB <=> cb.nameCB;
    field String nameB <=> cb.nameB;
}


transfer TransferTester maps Tester as t {

    relation TB b <= t.b choices:B.all();
    relation TB[] bs <= t.bs choices:B.all();
    relation TB caAsB <= t.caAsB choices:B.all();
    relation TB[] caAsBs <= t.caAsBs choices:B.all();

    field Boolean kindOfA <= t.kindOfA;        // true
    field Boolean kindOfB <= t.kindOfB;        // true
    field Boolean kindOfCA <= t.kindOfCA;      // false
    field Boolean kindOfCA1 <= t.kindOfCA1;    // true
    field Boolean kindOfCB <= t.kindOfCB;      // false

    // type of
    field Boolean typeOfA <= t.typeOfA;        // false
    field Boolean typeOfB <= t.typeOfB;        // true
    field Boolean typeOfCA <= t.typeOfCA;      // false
    field Boolean typeOfCA1 <= t.typeOfCA1;    // true
    field Boolean typeOfCB <= t.typeOfCB;      // false

    // as type
    relation TA asTypeA <= t.asTypeA;           // B
    relation TB asTypeB <= t.asTypeB;            // B
    relation TCA asTypeCA <= t.asTypeCA;        // undefined
    relation TCA asTypeCA1 <= t.asTypeCA1;      // CA
    relation TCB asTypeCB <= t.asTypeCB;        // undefined

    // as collection
    relation TA[] asCollectionA <= t.asCollectionA;         // B-s
    relation TB[] asCollectionB <= t.asCollectionB;         // B-s
    relation TCA[] asCollectionCA <= t.asCollectionCA;      // empty
    relation TCA[] asCollectionCA1 <= t.asCollectionCA1;    // CA-s
    relation TCB[] asCollectionCB <= t.asCollectionCB;      // empty

    // SubTypeExpression
    relation TA[] caAs <= t.caAs;
    relation TB[] caBs <= t.caBs;
    relation TCA[] caCAs <= t.caCAs;
    relation TCB[] caCBs <= t.caCBs;
    relation TB[] caAsCollectionB <= t.caAsCollectionB;
}
